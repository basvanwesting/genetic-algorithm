StrategyBuilder with_rng. if needed for seeds
with_rng_seed?
Default to thread_rng
Set seeds for test, check rand docs
Fixed type or RNG trait?
Spawn for thread
Is par deterministic? Maybe seed won”t help as work stealing is  not deterministic. Check rayon docs

Use SmallRng as fixed type for EvolveBuilder and Evolve
When cloning use SmallRng::from_rng(rand::thread_rng()).unwrap(), other wise the clone is identical rng
SmallRng is notably faster than thread_rng in sequential usage.
ThreadRng is the best option for parallel usage. This strikes a balance.
Add with_rng_seed(u64) in builder for tests. Note that Rng and Parallel is never deterministic for tests

par_mutate with call and call_par?
Or seperate structs? MutateSingleGene & ParMutateSingleGene?
Or internal with flag in paramaters?

Target cardinality range for dynamic to avoid constant switching

Store samplers on mutate etc. Just like genotype

Make fitness immutable?

Add CountTrueWithWork?


multithreading for CrossoverUniform(false)
multithreading for CompeteTournament
multithreading for MutateSingleGene


crossovers-pop1000/Uniform(Uniform { keep_parent: false })-single-thread/10    time: [55.650 µs]
crossovers-pop1000/Uniform(Uniform { keep_parent: false })-multi-thread/10     time: [141.90 µs]
crossovers-pop1000/Uniform(Uniform { keep_parent: false })-single-thread/100   time: [252.51 µs]
crossovers-pop1000/Uniform(Uniform { keep_parent: false })-multi-thread/100    time: [292.78 µs]
crossovers-pop1000/Uniform(Uniform { keep_parent: false })-single-thread/1000  time: [2.3076 ms]
crossovers-pop1000/Uniform(Uniform { keep_parent: false })-multi-thread/1000   time: [1.4462 ms]
crossovers-pop1000/Uniform(Uniform { keep_parent: false })-single-thread/10000 time: [21.631 ms]
crossovers-pop1000/Uniform(Uniform { keep_parent: false })-multi-thread/10000  time: [9.5185 ms]

Add on_equal_fitness to Evolve as well?
still counts as stale generations


[HillClimbVariant::Stochastic]:
  with_scaling: 
    move only on edges of scale
    scale down after max_stale_generations
    stop if max_stale_generations reached at smallest scale
  without_scaling: 
    mutate uniformly over range (neighbour_range or allele_range fallback)
    stop if max_stale_generations reached
  with_on_equal_fitness:
    high max_stale_generations
  without_on_equal_fitness:
    high max_stale_generations

[HillClimbVariant::SteepestAscent]:
  with_scaling: 
    move only on edges of scale
    scale down after max_stale_generations
    stop if max_stale_generations reached at smallest scale
  without_scaling: 
    mutate uniformly over range (neighbour_range or allele_range fallback), ensure lower and higher neighbour
    stop if max_stale_generations reached
  with_on_equal_fitness:
    high max_stale_generations
  without_on_equal_fitness:
    no max_stale_generations, by definition 1

[HillClimbVariant::StochasticSecondary]:
  scaling not implemented, secondary only for "swaps"

[HillClimbVariant::SteepestAscentSecondary]:
  scaling not implemented, secondary only for "swaps"


1.0 to <1e-5 = 110 gens at 0.9
1.0 to <1e-5 = 50  gens at 0.8
1.0 to <1e-5 = 34  gens at 0.7
1.0 to <1e-5 = 24  gens at 0.6
1.0 to <1e-5 = 18  gens at 0.5
